<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width,initial-scale=1" />
    <title>face-api.js — Face + Expression Overlay</title>
    <style>
      :root {
        color-scheme: dark;
      }
      body {
        margin: 0;
        background: #0b0b0c;
        color: #fff;
        font-family: system-ui, -apple-system, Segoe UI, Roboto, sans-serif;
      }
      .wrap {
        min-height: 100svh;
        display: grid;
        place-items: center;
        gap: 12px;
        padding: 24px;
      }
      .stage {
        position: relative;
        width: min(720px, 94vw);
      }
      video,
      canvas {
        width: 100%;
        height: auto;
        display: block;
        border-radius: 16px;
      }
      #hud {
        position: absolute;
        left: 12px;
        top: 12px;
        z-index: 5;
        padding: 8px 12px;
        font-size: 14px;
        border-radius: 12px;
        background: rgba(20, 20, 24, 0.6);
        backdrop-filter: blur(6px);
      }
      #caption {
        position: absolute;
        left: 50%;
        transform: translateX(-50%);
        bottom: 14px;
        z-index: 5;
        padding: 6px 12px;
        font-size: 13px;
        border-radius: 999px;
        letter-spacing: 0.2px;
        background: rgba(15, 15, 20, 0.68);
        display: none;
      }
    </style>
  </head>
  <body>
    <div class="wrap">
      <div class="stage">
        <div id="hud">loading…</div>
        <video id="video" autoplay muted playsinline></video>
        <canvas id="overlay"></canvas>
        <div id="caption">nonchalant observer</div>
      </div>
    </div>

    <!-- Runtimes -->
    <script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs@4.20.0/dist/tf.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/face-api.js@0.22.2/dist/face-api.min.js"></script>

    <script>
      const video = document.getElementById("video");
      const overlay = document.getElementById("overlay");
      const ctx = overlay.getContext("2d");
      const hud = document.getElementById("hud");
      const caption = document.getElementById("caption");

      // --- neutral smoothing + hysteresis to avoid flicker ---
      const neutralBuf = [];
      const BUF_SIZE = 10; // frames to average
      const NEUTRAL_ON = 0.65; // turn on caption when avg >= 0.65
      const NEUTRAL_OFF = 0.55; // turn off when avg < 0.55
      let captionOn = false;

      function pushNeutral(p) {
        neutralBuf.push(p);
        if (neutralBuf.length > BUF_SIZE) neutralBuf.shift();
        return neutralBuf.reduce((a, b) => a + b, 0) / neutralBuf.length;
      }

      function bestExpression(expressions) {
        let best = { name: "unknown", score: 0 };
        for (const [name, score] of Object.entries(expressions))
          if (score > best.score) best = { name, score };
        return best;
      }

      function drawBox(box) {
        ctx.strokeStyle = "rgba(255,255,255,.85)";
        ctx.lineWidth = 2;
        ctx.setLineDash([]);
        ctx.strokeRect(box.x, box.y, box.width, box.height);
      }

      function drawLabelOverBox(box, text) {
        const pad = 6;
        ctx.font = "14px system-ui, sans-serif";
        const metrics = ctx.measureText(text);
        const tw = metrics.width,
          th = 18;
        const tx = box.x + Math.max(0, (box.width - tw) / 2);
        const ty = Math.max(0, box.y - th - 8);

        // background pill
        ctx.fillStyle = "rgba(0,0,0,0.6)";
        ctx.fillRect(tx - pad, ty - th + 4, tw + pad * 2, th);

        // text
        ctx.fillStyle = "white";
        ctx.fillText(text, tx, ty);
      }

      function drawNeutralOverlay(box) {
        ctx.save();
        ctx.setLineDash([8, 6]);
        ctx.strokeStyle = "rgba(255,255,255,.9)";
        ctx.lineWidth = 2;
        ctx.strokeRect(box.x, box.y, box.width, box.height);

        const r = Math.max(box.width, box.height);
        const grad = ctx.createRadialGradient(
          box.x + box.width / 2,
          box.y + box.height / 2,
          r * 0.1,
          box.x + box.width / 2,
          box.y + box.height / 2,
          r * 0.7
        );
        grad.addColorStop(0, "rgba(255,255,255,0.03)");
        grad.addColorStop(1, "rgba(0,0,0,0.45)");
        ctx.fillStyle = grad;
        ctx.fillRect(box.x, box.y, box.width, box.height);
        ctx.restore();
      }

      async function loadModels() {
        const MODEL_URL = "./models";
        await Promise.all([
          faceapi.nets.tinyFaceDetector.loadFromUri(MODEL_URL),
          faceapi.nets.faceExpressionNet.loadFromUri(MODEL_URL),
        ]);
      }

      async function setupCamera() {
        const stream = await navigator.mediaDevices.getUserMedia({
          video: {
            facingMode: "user",
            width: { ideal: 1280 },
            height: { ideal: 720 },
          },
          audio: false,
        });
        video.srcObject = stream;
        await new Promise((r) => (video.onloadedmetadata = r));
        overlay.width = video.videoWidth;
        overlay.height = video.videoHeight;
      }

      (async function run() {
        try {
          hud.textContent = "loading models…";
          await loadModels();

          hud.textContent = "starting camera…";
          await setupCamera();

          const opts = new faceapi.TinyFaceDetectorOptions({
            inputSize: 320, // 256–416 is a good range
            scoreThreshold: 0.5,
          });

          hud.textContent = "ready";

          async function tick() {
            const result = await faceapi
              .detectSingleFace(video, opts)
              .withFaceExpressions();

            ctx.clearRect(0, 0, overlay.width, overlay.height);

            if (result) {
              const { box } = result.detection;
              drawBox(box);

              // expression results
              const best = bestExpression(result.expressions);
              const pct = (best.score * 100).toFixed(0);
              drawLabelOverBox(box, `${best.name} ${pct}%`);

              // neutral caption logic
              const avgNeutral = pushNeutral(result.expressions.neutral ?? 0);
              if (!captionOn && avgNeutral >= NEUTRAL_ON) captionOn = true;
              if (captionOn && avgNeutral < NEUTRAL_OFF) captionOn = false;

              if (captionOn) {
                drawNeutralOverlay(box);
                caption.style.display = "";
              } else {
                caption.style.display = "none";
              }

              hud.textContent = `expression: ${best.name} (neutral avg: ${
                (avgNeutral * 100) | 0
              }%)`;
            } else {
              caption.style.display = "none";
              hud.textContent = "no face detected";
            }

            requestAnimationFrame(tick);
          }

          tick();
        } catch (err) {
          console.error(err);
          hud.textContent = "error: " + err.message;
        }
      })();
    </script>
  </body>
</html>
