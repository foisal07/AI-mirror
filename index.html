<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width,initial-scale=1" />
    <title>AI Mirror — Expression Popup</title>
    <style>
      :root {
        color-scheme: dark;
      }
      * {
        box-sizing: border-box;
      }
      body {
        margin: 0;
        background: #0b0b0c;
        color: #fff;
        font-family: system-ui, -apple-system, Segoe UI, Roboto, sans-serif;
      }
      .wrap {
        min-height: 100svh;
        display: grid;
        place-items: center;
        gap: 14px;
        padding: 0;
      }
      .stage {
        position: relative;
        width: 100vw;
        height: 100vh;
      }
      video,
      canvas {
        width: 100%;
        height: 100%;
        display: block;
        object-fit: cover;
      }

      /* Loading overlay */
      #loader {
        position: absolute;
        inset: 0;
        display: flex;
        align-items: center;
        justify-content: center;
        background: rgba(0, 0, 0, 0.45);
        z-index: 20;
        pointer-events: none;
        opacity: 0;
        transition: opacity 0.25s ease;
      }
      #loader.show {
        opacity: 1;
        pointer-events: auto;
      }
      .spinner {
        width: 56px;
        height: 56px;
        border-radius: 50%;
        border: 6px solid rgba(255, 255, 255, 0.12);
        border-top-color: #fff;
        animation: spin 1s linear infinite;
        box-shadow: 0 6px 24px rgba(0, 0, 0, 0.5);
      }
      @keyframes spin {
        to {
          transform: rotate(360deg);
        }
      }

      #hud {
        position: absolute;
        left: 12px;
        top: 12px;
        z-index: 5;
        padding: 8px 12px;
        font-size: 14px;
        border-radius: 12px;
        background: rgba(20, 20, 24, 0.65);
        backdrop-filter: blur(6px);
      }

      #startBtn {
        appearance: none;
        border: 0;
        cursor: pointer;
        border-radius: 12px;
        padding: 10px 14px;
        background: #1e1e24;
        color: #fff;
        font-size: 14px;
        box-shadow: 0 2px 10px rgba(0, 0, 0, 0.25);
      }

      /* Popup / toast */
      #popup {
        position: fixed;
        left: 50%;
        top: 12%;
        transform: translateX(-50%) scale(0.98);
        padding: 16px 24px;
        border-radius: 14px;
        background: rgba(10, 10, 14, 0.9);
        box-shadow: 0 10px 30px rgba(0, 0, 0, 0.45),
          inset 0 0 0 1px rgba(255, 255, 255, 0.12);
        font-size: 20px;
        font-weight: 600;
        letter-spacing: 0.2px;
        z-index: 9999;
        opacity: 0;
        pointer-events: none;
        transition: opacity 0.3s ease, transform 0.3s ease;
        text-align: center;
      }
      #popup.show {
        opacity: 1;
        transform: translateX(-50%) scale(1);
        animation: pop 0.36s cubic-bezier(0.2, 0.9, 0.3, 1);
      }
      @keyframes pop {
        0% {
          transform: translateX(-50%) scale(0.92);
          opacity: 0;
        }
        60% {
          transform: translateX(-50%) scale(1.04);
          opacity: 1;
        }
        100% {
          transform: translateX(-50%) scale(1);
          opacity: 1;
        }
      }
      #popup small {
        opacity: 0.75;
        font-size: 14px;
        margin-left: 0.8ch;
        font-weight: normal;
      }

      /* Optional: expression label above box */
      .label-bg {
        fill: rgba(0, 0, 0, 0.6);
      }
    </style>
  </head>
  <body>
    <div class="wrap">
      <div class="stage">
        <div id="hud">loading…</div>
        <video id="video" autoplay muted playsinline></video>
        <canvas id="overlay"></canvas>
      </div>
      <button id="startBtn" aria-label="Start">▶ Start</button>
    </div>

    <!-- Loading overlay -->
    <div id="loader" aria-hidden="true">
      <div class="spinner" role="status" aria-hidden="true"></div>
    </div>

    <!-- Popup element -->
    <div id="popup" role="status" aria-live="polite"></div>

    <!-- Only face-api.js (no separate TFJS tag) -->
    <script src="https://cdn.jsdelivr.net/npm/face-api.js@0.22.2/dist/face-api.min.js"></script>

    <script>
      const video = document.getElementById("video");
      const overlay = document.getElementById("overlay");
      const ctx = overlay.getContext("2d");
      const hud = document.getElementById("hud");
      const startBtn = document.getElementById("startBtn");
      const popup = document.getElementById("popup");
      const loader = document.getElementById("loader");

      // speech permission flag — enabled by explicit user gesture (Start button)
      let allowSpeech = false;

      // Fun expression messages
      const expressionMessages = {
        happy: ["Radiant Comrade!", "Joy Spreader!", "Sunshine Champion!"],
        sad: ["Captain Serious", "Melancholy Poet", "Blue Mood Master"],
        angry: ["Thunder Face!", "Mighty Grumpy!", "Epic Rage Master!"],
        surprised: [
          "Shock Commander!",
          "Wide-Eyed Wonder!",
          "Surprise Expert!",
        ],
        neutral: ["Zen Master", "Poker Face Pro", "Calm Keeper"],
        fearful: ["Brave Explorer", "Adventure Seeker", "Thrill Master"],
        disgusted: ["Critic Supreme", "Taste Guardian", "Opinion Master"],
      };

      function getRandomMessage(expression) {
        const messages = expressionMessages[expression.toLowerCase()] || [
          "Mood Master",
        ];
        return messages[Math.floor(Math.random() * messages.length)];
      }

      // Popup helpers
      let popupTimer = null;
      function showPopup(text, conf, isWelcome = false) {
        popup.textContent = "";
        if (isWelcome) {
          popup.innerHTML = text;
        } else {
          const funMessage = getRandomMessage(text);
          popup.innerHTML = `${funMessage} <small>${Math.round(
            conf * 100
          )}%</small>`;
          // speak the message when allowed by a prior user gesture
          speak(funMessage);
        }
        popup.classList.add("show");
        clearTimeout(popupTimer);
        popupTimer = setTimeout(
          () => popup.classList.remove("show"),
          isWelcome ? 4000 : 1600
        );
      }

      function speak(text) {
        try {
          if (!allowSpeech) return;
          const u = new SpeechSynthesisUtterance(text);
          u.lang = navigator.language || "en-US";
          speechSynthesis.cancel();
          speechSynthesis.speak(u);
        } catch (e) {
          console.warn("speech failed", e);
        }
      }

      // Expression smoothing / change detection
      const SMOOTH_N = 6; // moving average window (frames)
      let history = []; // [{name, score}]
      let lastShown = { name: "", score: 0 };
      const CHANGE_THRESH = 0.12; // minimum change in score to consider "new"
      const SCORE_MIN_TO_ANNOUNCE = 0.55; // only announce if top score >= 0.55
      const MIN_MS_BETWEEN_POPUPS = 900;
      let lastPopupAt = 0;
      // track whether a face is currently visible (to show prompt once per appearance)
      let faceSeen = false;

      function bestExpression(expressions) {
        let best = { name: "unknown", score: 0 };
        for (const [name, score] of Object.entries(expressions))
          if (score > best.score) best = { name, score };
        return best;
      }

      function smoothBest(newBest) {
        history.push(newBest);
        if (history.length > SMOOTH_N) history.shift();
        // average scores per name seen in history
        const agg = {};
        history.forEach(({ name, score }) => {
          agg[name] = (agg[name] || 0) + score;
        });
        const smoothed = Object.entries(agg).map(([name, sum]) => ({
          name,
          score: sum / history.length,
        }));
        smoothed.sort((a, b) => b.score - a.score);
        return smoothed[0] || newBest;
      }

      function maybeAnnounce(best) {
        const now = Date.now();
        const changedName = best.name !== lastShown.name;
        const changedScore =
          Math.abs(best.score - (lastShown.score || 0)) >= CHANGE_THRESH;
        const confident = best.score >= SCORE_MIN_TO_ANNOUNCE;
        const cooledDown = now - lastPopupAt >= MIN_MS_BETWEEN_POPUPS;

        if (confident && cooledDown && (changedName || changedScore)) {
          showPopup(best.name, best.score);
          lastShown = best;
          lastPopupAt = now;
        }
      }

      function drawBox(box) {
        ctx.strokeStyle = "rgba(255,255,255,.9)";
        ctx.lineWidth = 2;
        ctx.setLineDash([]);
        ctx.strokeRect(box.x, box.y, box.width, box.height);
      }

      function drawLabelOverBox(box, text) {
        const pad = 6;
        ctx.font = "14px system-ui, sans-serif";
        const tw = ctx.measureText(text).width,
          th = 18;
        const tx = box.x + Math.max(0, (box.width - tw) / 2);
        const ty = Math.max(0, box.y - th - 8);
        ctx.fillStyle = "rgba(0,0,0,0.6)";
        ctx.fillRect(tx - pad, ty - th + 4, tw + pad * 2, th);
        ctx.fillStyle = "white";
        ctx.fillText(text, tx, ty);
      }

      function ensureCanvasSizeMatchesVideo() {
        if (
          overlay.width !== video.videoWidth ||
          overlay.height !== video.videoHeight
        ) {
          overlay.width = video.videoWidth;
          overlay.height = video.videoHeight;
        }
      }

      async function loadModels() {
        // Handle both local and GitHub Pages paths
        const repoName = "AI-mirror";
        const MODEL_URL =
          location.hostname === "localhost" || location.hostname === "127.0.0.1"
            ? "./models"
            : `/${repoName}/models`;

        hud.textContent = "loading models…";
        showLoader();
        try {
          await Promise.all([
            faceapi.nets.tinyFaceDetector.loadFromUri(MODEL_URL),
            faceapi.nets.faceExpressionNet.loadFromUri(MODEL_URL),
          ]);
          hud.textContent = "models ready";
          hideLoader();
        } catch (error) {
          console.error("Error loading models:", error);
          hud.textContent = `Error loading models from ${MODEL_URL}. Check console for details.`;
          hideLoader();
          throw error;
        }
      }

      async function setupCamera() {
        hud.textContent = "requesting camera…";
        showLoader();
        const stream = await navigator.mediaDevices.getUserMedia({
          video: {
            facingMode: "user",
            width: { ideal: 1280 },
            height: { ideal: 720 },
          },
          audio: false,
        });
        video.srcObject = stream;
        await new Promise((r) => (video.onloadedmetadata = r));
        overlay.width = video.videoWidth;
        overlay.height = video.videoHeight;
        hud.textContent = "camera ready";
        hideLoader();
      }

      function showLoader() {
        loader.classList.add("show");
      }
      function hideLoader() {
        loader.classList.remove("show");
      }

      async function startApp() {
        try {
          startBtn.disabled = true;
          await loadModels();
          await setupCamera();

          // Show welcome message
          showPopup(
            "👋 Show me your expressions!<br>I'll tell you what I see...",
            1,
            true
          );

          const opts = new faceapi.TinyFaceDetectorOptions({
            inputSize: 320,
            scoreThreshold: 0.5,
          });
          hud.textContent = "detecting…";

          async function tick() {
            ensureCanvasSizeMatchesVideo();
            const result = await faceapi
              .detectSingleFace(video, opts)
              .withFaceExpressions();

            ctx.clearRect(0, 0, overlay.width, overlay.height);

            if (result) {
              // when a face is first seen, prompt the user to make an expression
              if (!faceSeen) {
                showPopup("👀 I see you — show me a face!", 1, true);
                faceSeen = true;
              }

              const { box } = result.detection;
              drawBox(box);

              const expr = result.expressions || {};
              const keys = Object.keys(expr);

              if (!keys.length) {
                hud.textContent =
                  "face found — expressions missing (check ./models)";
                requestAnimationFrame(tick);
                return;
              }

              const rawBest = bestExpression(expr);
              const best = smoothBest(rawBest);

              // Draw small label above box
              const pct = (best.score * 100).toFixed(0);
              drawLabelOverBox(box, `${best.name} ${pct}%`);

              // Popup if changed / confident
              maybeAnnounce(best);

              hud.textContent = `expression: ${best.name} (${pct}%)`;
            } else {
              // reset faceSeen so prompt will show again when face reappears
              faceSeen = false;
              hud.textContent = "no face detected";
            }

            requestAnimationFrame(tick);
          }

          tick();
        } catch (err) {
          console.error(err);
          hud.textContent = "error: " + err.message;
          startBtn.disabled = false;
        }
      }

      // Mobile needs a user gesture
      startBtn.addEventListener("click", (ev) => {
        allowSpeech = true;
        startApp();
      });
      // Try auto-start on desktop
      window.addEventListener("load", () => {
        startApp().catch(() => {});
      });
    </script>
  </body>
</html>
