<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width,initial-scale=1" />
    <meta name="orientation" content="portrait" />
    <title>AI Mirror â€” Expression Popup</title>
    <style>
      :root {
        color-scheme: dark;
      }
      * {
        box-sizing: border-box;
      }
      body {
        margin: 0;
        background: #0b0b0c;
        color: #fff;
        font-family: system-ui, -apple-system, Segoe UI, Roboto, sans-serif;
        /* prevent scroll/bounce on mobile */
        position: fixed;
        inset: 0;
        overflow: hidden;
      }
      .wrap {
        min-height: 100svh;
        display: block;
        padding: 0;
      }
      .stage {
        position: relative;
        width: 100%;
        height: 100svh;
        /* Force portrait aspect ratio even in landscape */
        max-width: min(100%, calc(100svh * 0.5625)); /* 9:16 ratio */
        margin: 0 auto;
        background: #000;
      }
      video,
      canvas {
        position: absolute;
        inset: 0;
        width: 100%;
        height: 100%;
        display: block;
        object-fit: cover;
        /* ensure video stays centered */
        transform-origin: center;
      }

      /* Force portrait layout */
      @media screen and (orientation: portrait) {
        html {
          /* Lock screen to portrait */
          min-height: -webkit-fill-available;
        }
      }
      @media (orientation: landscape) {
        .stage {
          height: 100svh;
          max-width: min(100%, calc(100svh * 0.5625));
        }
        video {
          /* Ensure video feed is rotated to portrait in landscape mode */
          transform: scale(1.1); /* Slight scale up to prevent gaps */
        }
        html {
          /* Request portrait mode on supported devices */
          min-height: -webkit-fill-available;
        }
      }

      /* Loading overlay */
      #loader {
        position: absolute;
        inset: 0;
        display: flex;
        align-items: center;
        justify-content: center;
        background: rgba(0, 0, 0, 0.45);
        z-index: 20;
        pointer-events: none;
        opacity: 0;
        transition: opacity 0.25s ease;
      }
      #loader.show {
        opacity: 1;
        pointer-events: auto;
      }
      .spinner {
        width: 56px;
        height: 56px;
        border-radius: 50%;
        border: 6px solid rgba(255, 255, 255, 0.12);
        border-top-color: #fff;
        animation: spin 1s linear infinite;
        box-shadow: 0 6px 24px rgba(0, 0, 0, 0.5);
      }
      @keyframes spin {
        to {
          transform: rotate(360deg);
        }
      }

      /* Face scanning overlay */
      #scanner {
        position: absolute;
        inset: 0;
        display: flex;
        flex-direction: column;
        align-items: center;
        justify-content: center;
        gap: 18px;
        z-index: 6;
        opacity: 0;
        pointer-events: none;
        transition: opacity 0.3s ease;
        background: radial-gradient(
            circle at center,
            rgba(0, 255, 204, 0.05),
            transparent 60%
          ),
          rgba(0, 0, 0, 0.15);
        backdrop-filter: blur(2px);
      }
      #scanner.show {
        opacity: 1;
      }
      .scanner-frame {
        width: min(70%, 360px);
        aspect-ratio: 3 / 4;
        border: 1px solid rgba(0, 255, 204, 0.4);
        border-radius: 24px;
        position: relative;
        overflow: hidden;
        box-shadow: 0 15px 35px rgba(0, 0, 0, 0.45);
      }
      .scanner-grid {
        position: absolute;
        inset: 0;
        background-image: linear-gradient(
            rgba(0, 255, 204, 0.08) 1px,
            transparent 1px
          ),
          linear-gradient(
            90deg,
            rgba(0, 255, 204, 0.08) 1px,
            transparent 1px
          );
        background-size: 40px 40px;
      }
      .scanner-line {
        position: absolute;
        left: 0;
        width: 100%;
        height: 8px;
        background: linear-gradient(
          90deg,
          transparent,
          rgba(0, 255, 204, 0.9),
          transparent
        );
        box-shadow: 0 0 16px rgba(0, 255, 204, 0.75);
        animation: scannerSweep 2s ease-in-out infinite;
      }
      @keyframes scannerSweep {
        0% {
          top: 0;
        }
        50% {
          top: calc(100% - 8px);
        }
        100% {
          top: 0;
        }
      }
      .scanner-text {
        text-align: center;
        font-size: 16px;
        font-weight: 600;
        text-transform: uppercase;
        letter-spacing: 0.3ch;
      }
      .scanner-text small {
        display: block;
        margin-top: 6px;
        font-size: 12px;
        letter-spacing: normal;
        text-transform: none;
        opacity: 0.8;
      }
      .fingerprint {
        position: relative;
        width: 58px;
        height: 58px;
        border: 3px solid #aab8be;
        border-radius: 50%;
        margin: 0 auto;
        opacity: 0.85;
        overflow: hidden;
        pointer-events: none;
      }
      .fingerprint.scanning::after {
        content: "";
        position: absolute;
        top: 0;
        left: 0;
        width: 58px;
        height: 8px;
        background-image: linear-gradient(
          to bottom,
          rgba(170, 184, 190, 0),
          rgba(170, 184, 190, 0.8)
        );
        animation: scanning 0.8s linear infinite;
        border-radius: 50%;
      }
      @keyframes scanning {
        100% {
          transform: translateY(52px);
        }
      }

      #hud {
        position: absolute;
        left: 12px;
        top: 12px;
        z-index: 5;
        /* hide HUD for fullscreen camera mode */
        display: none !important;
        padding: 8px 12px;
        font-size: 14px;
        border-radius: 12px;
        background: rgba(20, 20, 24, 0.65);
        backdrop-filter: blur(6px);
      }

      #startBtn {
        appearance: none;
        border: 0;
        cursor: pointer;
        border-radius: 12px;
        padding: 10px 14px;
        background: #1e1e24;
        color: #fff;
        font-size: 14px;
        box-shadow: 0 2px 10px rgba(0, 0, 0, 0.25);
        /* hide start button under the camera for fully immersive fullscreen */
        display: none !important;
      }

      /* Popup / toast */
      #popup {
        position: fixed;
        left: 50%;
        top: 12%;
        transform: translateX(-50%) scale(0.98);
        padding: 16px 24px;
        border-radius: 14px;
        background: rgba(10, 10, 14, 0.9);
        box-shadow: 0 10px 30px rgba(0, 0, 0, 0.45),
          inset 0 0 0 1px rgba(255, 255, 255, 0.12);
        font-size: 20px;
        font-weight: 600;
        letter-spacing: 0.2px;
        z-index: 9999;
        opacity: 0;
        pointer-events: none;
        transition: opacity 0.3s ease, transform 0.3s ease;
        text-align: center;
      }
      #popup.show {
        opacity: 1;
        transform: translateX(-50%) scale(1);
        animation: pop 0.36s cubic-bezier(0.2, 0.9, 0.3, 1);
      }
      @keyframes pop {
        0% {
          transform: translateX(-50%) scale(0.92);
          opacity: 0;
        }
        60% {
          transform: translateX(-50%) scale(1.04);
          opacity: 1;
        }
        100% {
          transform: translateX(-50%) scale(1);
          opacity: 1;
        }
      }
      #popup small {
        opacity: 0.75;
        font-size: 14px;
        margin-left: 0.8ch;
        font-weight: normal;
      }
      #popup .popup-expression {
        display: block;
        font-size: 13px;
        letter-spacing: 0.4ch;
        text-transform: uppercase;
        opacity: 0.6;
        margin-bottom: 8px;
      }
      #popup .popup-main {
        font-size: 20px;
        letter-spacing: 0.2px;
      }

      /* Optional: expression label above box */
      .label-bg {
        fill: rgba(0, 0, 0, 0.6);
      }
    </style>
  </head>
  <body>
    <div class="wrap">
      <div class="stage">
        <div id="hud">loadingâ€¦</div>
        <video id="video" autoplay muted playsinline></video>
        <canvas id="overlay"></canvas>
        <div id="scanner" aria-hidden="true">
          <div class="scanner-frame">
            <div class="scanner-grid"></div>
            <div class="scanner-line"></div>
          </div>
          <div class="fingerprint scanning" aria-hidden="true"></div>
          <div class="scanner-text">
            <span>Scanning face</span>
            <small>Hold steady while we lock on</small>
          </div>
        </div>
      </div>
      <button id="startBtn" aria-label="Start">â–¶ Start</button>
    </div>

    <!-- Loading overlay -->
    <div id="loader" aria-hidden="true">
      <div class="spinner" role="status" aria-hidden="true"></div>
    </div>

    <!-- Popup element -->
    <div id="popup" role="status" aria-live="polite"></div>

    <!-- Audio + ML libraries -->
    <script src="https://cdn.jsdelivr.net/npm/howler@2.2.4/dist/howler.min.js"></script>
    <!-- Only face-api.js (no separate TFJS tag) -->
    <script src="https://cdn.jsdelivr.net/npm/face-api.js@0.22.2/dist/face-api.min.js"></script>

    <script>
      const video = document.getElementById("video");
      const overlay = document.getElementById("overlay");
      const ctx = overlay.getContext("2d");
      const hud = document.getElementById("hud");
      const startBtn = document.getElementById("startBtn");
      const popup = document.getElementById("popup");
      const loader = document.getElementById("loader");
      const scanner = document.getElementById("scanner");

      // speech permission flag â€” enabled by explicit user gesture (Start button)
      let allowSpeech = true;

      // Fun expression messages
      const expressionMessages = {
        happy: ["Radiant Comrade!", "Joy Spreader!", "Sunshine Champion!"],
        sad: ["Captain Serious", "Melancholy Poet", "Blue Mood Master"],
        angry: ["Thunder Face!", "Mighty Grumpy!", "Epic Rage Master!"],
        surprised: [
          "Shock Commander!",
          "Wide-Eyed Wonder!",
          "Surprise Expert!",
        ],
        neutral: ["Zen Master", "Poker Face Pro", "Calm Keeper"],
        fearful: ["Brave Explorer", "Adventure Seeker", "Thrill Master"],
        disgusted: ["Critic Supreme", "Taste Guardian", "Opinion Master"],
      };

      // Short witty subtitles to show under the main popup message
      const expressionSubtitles = {
        happy: [
          "Warning: excessive joy detected.",
          "Smile quota exceeded â€” congratulations!",
        ],
        sad: [
          "Expert-level brooding in progress.",
          "Steam: handle with kindness.",
        ],
        angry: ["Calm breathing recommended.", "Hot vibes cooling down soon."],
        surprised: ["Blink to confirm reality.", "Alert: curiosity peaked!"],
        neutral: ["Zen mode activated.", "Stoic and stylish."],
        fearful: ["Adrenaline: optional.", "Courage boots are on backorder."],
        disgusted: ["Tastebuds offended.", "Opinionated and proud."],
        default: [
          "Mood detected â€” processing witty comment.",
          "Nice face, nice vibes.",
        ],
      };

      function getRandomSubtitle(expression) {
        const arr =
          expressionSubtitles[expression.toLowerCase()] ||
          expressionSubtitles.default;
        return arr[Math.floor(Math.random() * arr.length)];
      }

      function getRandomMessage(expression) {
        const messages = expressionMessages[expression.toLowerCase()] || [
          "Mood Master",
        ];
        return messages[Math.floor(Math.random() * messages.length)];
      }

      function formatExpressionLabel(expression) {
        if (!expression) return "Expression detected";
        return expression
          .toString()
          .split(/[\s_-]+/)
          .map(
            (part) => part.charAt(0).toUpperCase() + part.slice(1).toLowerCase()
          )
          .join(" ");
      }

      // Popup helpers
      let popupTimer = null;
      function showPopup(text, conf, isWelcome = false) {
        popup.textContent = "";
        if (isWelcome) {
          popup.innerHTML = text;
        } else {
          const caption = formatExpressionLabel(text);
          const funMessage = getRandomMessage(text);
          const subtitle = getRandomSubtitle(text);
          // If the main message matches the special long heading, append playful emojis
          const specialHeading =
            "We noticed you didnâ€™t smile. Recreational scrolling reduced.";
          const emojiTail = funMessage === specialHeading ? " ðŸ˜…ðŸ“µ" : "";
          popup.innerHTML = `<div class=\"popup-expression\">${caption}</div><div class=\"popup-main\">${funMessage}${emojiTail}</div><small>${subtitle}</small>`;
          // speak the detected expression when allowed by a prior user gesture
          speak(caption);
        }
        popup.classList.add("show");
        clearTimeout(popupTimer);
        popupTimer = setTimeout(
          () => popup.classList.remove("show"),
          isWelcome ? 4000 : 2500
        );
      }

      function speak(text) {
        try {
          if (!allowSpeech) return;
          const u = new SpeechSynthesisUtterance(text);
          u.lang = navigator.language || "en-US";
          speechSynthesis.cancel();
          speechSynthesis.speak(u);
        } catch (e) {
          console.warn("speech failed", e);
        }
      }

      // Expression smoothing / change detection
      const SMOOTH_N = 4; // moving average window (frames)
      let history = []; // [{name, score}]
      let lastShown = { name: "", score: 0 };
      const CHANGE_THRESH = 0.1; // minimum change in score to consider "new"
      const SCORE_MIN_TO_ANNOUNCE = 0.45; // only announce if top score >= 0.45
      const MIN_MS_BETWEEN_POPUPS = 3000; // 3 seconds between expressions
      let lastPopupAt = 0;
      // track whether a face is currently visible (to show prompt once per appearance)
      let faceSeen = false;
      // track when expressions should start being announced (after scanning finishes)
      let startExpressionsTime = 0;
      // track when face disappeared
      let faceDisappearedTime = 0;
      const FACE_ABSENT_THRESHOLD = 30000; // 30 seconds in milliseconds
      const SCAN_MIN_DURATION = 3000; // scanning overlay minimum duration
      const SCAN_MAX_DURATION = 5000; // scanning overlay maximum duration
      const SCAN_AUDIO_VOLUME = 0.35; // audio level for scan sound

      let scanSound = null;
      let scanSoundPlaying = false;

      function scheduleScanHold(now) {
        const duration =
          SCAN_MIN_DURATION +
          Math.random() * (SCAN_MAX_DURATION - SCAN_MIN_DURATION);
        startExpressionsTime = now + duration;
      }

      function ensureScanSound() {
        if (scanSound) return scanSound;
        if (typeof Howl === "undefined") return null;
        scanSound = new Howl({
          src: ["scan.wav"],
          loop: true,
          volume: SCAN_AUDIO_VOLUME,
          preload: true,
        });
        return scanSound;
      }

      function startScanSound() {
        const sound = ensureScanSound();
        if (!sound || scanSoundPlaying) return;
        sound.stop();
        sound.play();
        scanSoundPlaying = true;
      }

      function stopScanSound() {
        if (!scanSound || !scanSoundPlaying) return;
        scanSound.stop();
        scanSoundPlaying = false;
      }

      function bestExpression(expressions) {
        let best = { name: "unknown", score: 0 };
        for (const [name, score] of Object.entries(expressions))
          if (score > best.score) best = { name, score };
        return best;
      }

      function smoothBest(newBest) {
        history.push(newBest);
        if (history.length > SMOOTH_N) history.shift();
        // average scores per name seen in history
        const agg = {};
        history.forEach(({ name, score }) => {
          agg[name] = (agg[name] || 0) + score;
        });
        const smoothed = Object.entries(agg).map(([name, sum]) => ({
          name,
          score: sum / history.length,
        }));
        smoothed.sort((a, b) => b.score - a.score);
        return smoothed[0] || newBest;
      }

      function maybeAnnounce(best) {
        const now = Date.now();
        // Don't show expressions until after the delay
        if (now < startExpressionsTime) return;

        // Clear the welcome message when we start showing expressions
        if (lastShown.name === "") {
          popup.classList.remove("show");
          clearTimeout(popupTimer);
        }

        const changedName = best.name !== lastShown.name;
        const changedScore =
          Math.abs(best.score - (lastShown.score || 0)) >= CHANGE_THRESH;
        const confident = best.score >= SCORE_MIN_TO_ANNOUNCE;
        const cooledDown = now - lastPopupAt >= MIN_MS_BETWEEN_POPUPS;

        if (confident && cooledDown && (changedName || changedScore)) {
          showPopup(best.name, best.score);
          lastShown = best;
          lastPopupAt = now;
        }
      }

      function drawBox(box) {
        ctx.strokeStyle = "rgba(255,255,255,.9)";
        ctx.lineWidth = 2;
        ctx.setLineDash([]);
        ctx.strokeRect(box.x, box.y, box.width, box.height);
      }

      function drawLabelOverBox(box, text) {
        const pad = 6;
        ctx.font = "14px system-ui, sans-serif";
        const tw = ctx.measureText(text).width,
          th = 18;
        const tx = box.x + Math.max(0, (box.width - tw) / 2);
        const ty = Math.max(0, box.y - th - 8);
        ctx.fillStyle = "rgba(0,0,0,0.6)";
        ctx.fillRect(tx - pad, ty - th + 4, tw + pad * 2, th);
        ctx.fillStyle = "white";
        ctx.fillText(text, tx, ty);
      }

      function ensureCanvasSizeMatchesVideo() {
        if (
          overlay.width !== video.videoWidth ||
          overlay.height !== video.videoHeight
        ) {
          overlay.width = video.videoWidth;
          overlay.height = video.videoHeight;
        }
      }

      async function loadModels() {
        // Handle both local and GitHub Pages paths
        const repoName = "AI-mirror";
        const MODEL_URL =
          location.hostname === "localhost" || location.hostname === "127.0.0.1"
            ? "./models"
            : `/${repoName}/models`;

        hud.textContent = "loading modelsâ€¦";
        showLoader();
        try {
          await Promise.all([
            faceapi.nets.tinyFaceDetector.loadFromUri(MODEL_URL),
            faceapi.nets.faceExpressionNet.loadFromUri(MODEL_URL),
          ]);
          hud.textContent = "models ready";
          hideLoader();
        } catch (error) {
          console.error("Error loading models:", error);
          hud.textContent = `Error loading models from ${MODEL_URL}. Check console for details.`;
          hideLoader();
          throw error;
        }
      }

      async function setupCamera() {
        hud.textContent = "requesting cameraâ€¦";
        showLoader();
        const stream = await navigator.mediaDevices.getUserMedia({
          video: {
            facingMode: "user",
            width: { ideal: 720 },
            height: { ideal: 1280 },
            aspectRatio: { ideal: 0.5625 }, // 9:16 portrait ratio
          },
          audio: false,
        });
        video.srcObject = stream;
        await new Promise((r) => (video.onloadedmetadata = r));
        overlay.width = video.videoWidth;
        overlay.height = video.videoHeight;
        hud.textContent = "camera ready";
        hideLoader();
      }

      function showLoader() {
        loader.classList.add("show");
      }
      function hideLoader() {
        loader.classList.remove("show");
      }

      function showScanner() {
        if (!scanner) return;
        if (!scanner.classList.contains("show")) {
          scanner.classList.add("show");
          scanner.setAttribute("aria-hidden", "false");
        }
        startScanSound();
      }

      function hideScanner() {
        if (!scanner) return;
        if (scanner.classList.contains("show")) {
          scanner.classList.remove("show");
          scanner.setAttribute("aria-hidden", "true");
        }
        stopScanSound();
      }

      async function startApp() {
        try {
          startBtn.disabled = true;
          await loadModels();
          await setupCamera();

          const opts = new faceapi.TinyFaceDetectorOptions({
            inputSize: 320,
            scoreThreshold: 0.5,
          });
          hud.textContent = "detectingâ€¦";

          async function tick() {
            ensureCanvasSizeMatchesVideo();
            const result = await faceapi
              .detectSingleFace(video, opts)
              .withFaceExpressions();

            ctx.clearRect(0, 0, overlay.width, overlay.height);

            if (result) {
              const now = Date.now();
              const firstFrameWithFace = !faceSeen;
              if (firstFrameWithFace) {
                faceSeen = true;
                scheduleScanHold(now);
                showScanner();
                // Show popup only if face has been gone for 30 seconds
                if (
                  now - faceDisappearedTime >= FACE_ABSENT_THRESHOLD ||
                  faceDisappearedTime === 0
                ) {
                  showPopup("ðŸ‘€ I see you â€” show me a face!", 1, true);
                }
              }

              const { box } = result.detection;
              drawBox(box);

              const expr = result.expressions || {};
              const keys = Object.keys(expr);

              if (!keys.length) {
                hud.textContent =
                  "face found â€” expressions missing (check ./models)";
                showScanner();
                requestAnimationFrame(tick);
                return;
              }

              const scanningActive =
                startExpressionsTime && now < startExpressionsTime;
              if (scanningActive) {
                showScanner();
              } else {
                hideScanner();
              }

              const rawBest = bestExpression(expr);
              const best = smoothBest(rawBest);

              // Draw small label above box
              if (!scanningActive) {
                const pct = (best.score * 100).toFixed(0);
                drawLabelOverBox(box, `${best.name} ${pct}%`);
                hud.textContent = `expression: ${best.name} (${pct}%)`;
              } else {
                hud.textContent = "scanning face...";
              }

              // Popup if changed / confident
              maybeAnnounce(best);
            } else {
              // reset face detection state when face disappears
              if (faceSeen) {
                // Only update disappearance time if we had seen a face
                faceDisappearedTime = Date.now();
              }
              faceSeen = false;
              startExpressionsTime = 0;
              hideScanner();
              hud.textContent = "no face detected";
            }

            requestAnimationFrame(tick);
          }

          tick();
        } catch (err) {
          console.error(err);
          hud.textContent = "error: " + err.message;
          startBtn.disabled = false;
        }
      }

      // Mobile needs a user gesture
      startBtn.addEventListener("click", (ev) => {
        allowSpeech = true;
        startApp();
      });
      // Try auto-start on desktop
      window.addEventListener("load", () => {
        startApp().catch(() => {});
      });
    </script>
  </body>
</html>
