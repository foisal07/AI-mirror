<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width,initial-scale=1" />
    <meta name="orientation" content="portrait" />
    <title>AI Mirror — Expression Popup</title>
    <style>
      :root {
        color-scheme: dark;
        --camera-width: min(100%, calc(100svh * 0.5625));
      }
      * {
        box-sizing: border-box;
      }
      body {
        margin: 0;
        background: #0b0b0c;
        color: #fff;
        font-family: system-ui, -apple-system, Segoe UI, Roboto, sans-serif;
        /* prevent scroll/bounce on mobile */
        position: fixed;
        inset: 0;
        overflow: hidden;
      }
      .wrap {
        min-height: 100svh;
        display: block;
        padding: 0;
      }
      .stage {
        position: relative;
        width: 100%;
        height: 100svh;
        /* Force portrait aspect ratio even in landscape */
        max-width: var(--camera-width); /* 9:16 ratio */
        margin: 0 auto;
        background: #000;
      }
      video,
      canvas {
        position: absolute;
        inset: 0;
        width: 100%;
        height: 100%;
        display: block;
        object-fit: cover;
        /* ensure video stays centered */
        transform-origin: center;
      }

      /* Force portrait layout */
      @media screen and (orientation: portrait) {
        html {
          /* Lock screen to portrait */
          min-height: -webkit-fill-available;
        }
      }
      @media (orientation: landscape) {
        .stage {
          height: 100svh;
          max-width: var(--camera-width);
        }
        video {
          /* Ensure video feed is rotated to portrait in landscape mode */
          transform: scale(1.1); /* Slight scale up to prevent gaps */
        }
        html {
          /* Request portrait mode on supported devices */
          min-height: -webkit-fill-available;
        }
      }

      /* Loading overlay */
      #loader {
        position: absolute;
        inset: 0;
        display: flex;
        align-items: center;
        justify-content: center;
        background: rgba(0, 0, 0, 0.45);
        z-index: 20;
        pointer-events: none;
        opacity: 0;
        transition: opacity 0.25s ease;
      }
      #loader.show {
        opacity: 1;
        pointer-events: auto;
      }
      .spinner {
        width: 56px;
        height: 56px;
        border-radius: 50%;
        border: 6px solid rgba(255, 255, 255, 0.12);
        border-top-color: #fff;
        animation: spin 1s linear infinite;
        box-shadow: 0 6px 24px rgba(0, 0, 0, 0.5);
      }
      @keyframes spin {
        to {
          transform: rotate(360deg);
        }
      }

      /* Face scanning overlay */
      #scanner {
        position: absolute;
        inset: 0;
        display: flex;
        flex-direction: column;
        align-items: center;
        justify-content: center;
        gap: 18px;
        z-index: 6;
        opacity: 0;
        pointer-events: none;
        transition: opacity 0.3s ease;
        background: radial-gradient(
            circle at center,
            rgba(0, 255, 204, 0.05),
            transparent 60%
          ),
          rgba(0, 0, 0, 0.15);
        backdrop-filter: blur(2px);
      }
      #scanner.show {
        opacity: 1;
      }
      .scanner-frame {
        width: min(70%, 360px);
        aspect-ratio: 3 / 4;
        border: 1px solid rgba(0, 255, 204, 0.4);
        border-radius: 24px;
        position: relative;
        overflow: hidden;
        box-shadow: 0 15px 35px rgba(0, 0, 0, 0.45);
      }
      .scanner-grid {
        position: absolute;
        inset: 0;
        background-image: linear-gradient(
            rgba(0, 255, 204, 0.08) 1px,
            transparent 1px
          ),
          linear-gradient(
            90deg,
            rgba(0, 255, 204, 0.08) 1px,
            transparent 1px
          );
        background-size: 40px 40px;
      }
      .scanner-line {
        position: absolute;
        left: 0;
        width: 100%;
        height: 8px;
        background: linear-gradient(
          90deg,
          transparent,
          rgba(0, 255, 204, 0.9),
          transparent
        );
        box-shadow: 0 0 16px rgba(0, 255, 204, 0.75);
        animation: scannerSweep 2s ease-in-out infinite;
      }
      @keyframes scannerSweep {
        0% {
          top: 0;
        }
        50% {
          top: calc(100% - 8px);
        }
        100% {
          top: 0;
        }
      }
      .scanner-text {
        text-align: center;
        font-size: 16px;
        font-weight: 600;
        text-transform: uppercase;
        letter-spacing: 0.3ch;
      }
      .scanner-text small {
        display: block;
        margin-top: 6px;
        font-size: 12px;
        letter-spacing: normal;
        text-transform: none;
        opacity: 0.8;
      }
      .fingerprint {
        position: relative;
        width: 58px;
        height: 58px;
        border: 3px solid #aab8be;
        border-radius: 50%;
        margin: 0 auto;
        opacity: 0.85;
        overflow: hidden;
        pointer-events: none;
      }
      .fingerprint.scanning::after {
        content: "";
        position: absolute;
        top: 0;
        left: 0;
        width: 58px;
        height: 8px;
        background-image: linear-gradient(
          to bottom,
          rgba(170, 184, 190, 0),
          rgba(170, 184, 190, 0.8)
        );
        animation: scanning 0.8s linear infinite;
        border-radius: 50%;
      }
      @keyframes scanning {
        100% {
          transform: translateY(52px);
        }
      }

      #hud {
        position: absolute;
        left: 12px;
        top: 12px;
        z-index: 5;
        /* hide HUD for fullscreen camera mode */
        display: none !important;
        padding: 8px 12px;
        font-size: 14px;
        border-radius: 12px;
        background: rgba(20, 20, 24, 0.65);
        backdrop-filter: blur(6px);
      }

      #startBtn {
        appearance: none;
        border: 0;
        cursor: pointer;
        border-radius: 12px;
        padding: 10px 14px;
        background: #1e1e24;
        color: #fff;
        font-size: 14px;
        box-shadow: 0 2px 10px rgba(0, 0, 0, 0.25);
        /* hide start button under the camera for fully immersive fullscreen */
        display: none !important;
      }

      /* Bottom ticker */
      #popup {
        position: fixed;
        left: 0;
        right: 0;
        bottom: 0;
        width: 100%;
        transform: translateY(100%);
        transition: transform 0.35s ease, opacity 0.35s ease;
        opacity: 0;
        pointer-events: none;
        z-index: 10;
      }
      #popup.show {
        transform: translateY(0);
        opacity: 1;
      }
      .ticker {
        display: flex;
        width: 100%;
        max-width: var(--camera-width);
        margin: 0 auto;
        min-height: 64px;
        font-family: "Oswald", "Impact", "Arial Narrow", sans-serif;
        text-transform: uppercase;
        color: #fff;
        box-shadow: 0 -8px 28px rgba(0, 0, 0, 0.5);
      }
      .ticker-label {
        background: #c10c16;
        padding: 10px 18px;
        letter-spacing: 0.35ch;
        font-size: clamp(12px, 2.6vw, 15px);
        font-weight: 700;
        display: flex;
        align-items: center;
      }
      .ticker-content {
        flex: 1;
        background: linear-gradient(90deg, #d41f1f, #a30d12);
        padding: 12px 18px;
        display: flex;
        flex-direction: column;
        gap: 4px;
      }
      .ticker-heading {
        font-size: clamp(16px, 4vw, 26px);
        font-weight: 800;
        letter-spacing: 0.2em;
      }
      .ticker-subtitle {
        font-size: clamp(12px, 3vw, 16px);
        letter-spacing: 0.1em;
        opacity: 0.9;
      }

      /* Optional: expression label above box */
      .label-bg {
        fill: rgba(0, 0, 0, 0.6);
      }
    </style>
  </head>
  <body>
    <div class="wrap">
      <div class="stage">
        <div id="hud">loading…</div>
        <video id="video" autoplay muted playsinline></video>
        <canvas id="overlay"></canvas>
        <div id="scanner" aria-hidden="true">
          <div class="scanner-frame">
            <div class="scanner-grid"></div>
            <div class="scanner-line"></div>
          </div>
          <div class="fingerprint scanning" aria-hidden="true"></div>
          <div class="scanner-text">
            <span>Scanning face</span>
            <small>Hold steady while we lock on</small>
          </div>
        </div>
      </div>
      <button id="startBtn" aria-label="Start">▶ Start</button>
    </div>

    <!-- Loading overlay -->
    <div id="loader" aria-hidden="true">
      <div class="spinner" role="status" aria-hidden="true"></div>
    </div>

    <!-- Popup element -->
        <div id="popup" role="status" aria-live="polite">
          <div class="ticker">
            <div class="ticker-label">AI Mirror</div>
            <div class="ticker-content">
              <div id="tickerHeading" class="ticker-heading">
                Awaiting face...
              </div>
              <div id="tickerSubtitle" class="ticker-subtitle">
                Bring your face into view
              </div>
            </div>
          </div>
        </div>

    <script src="https://cdn.jsdelivr.net/npm/howler@2.2.4/dist/howler.min.js"></script>
    <!-- Only face-api.js (no separate TFJS tag) -->
    <script src="https://cdn.jsdelivr.net/npm/face-api.js@0.22.2/dist/face-api.min.js"></script>

    <script>
      const video = document.getElementById("video");
      const overlay = document.getElementById("overlay");
      const ctx = overlay.getContext("2d");
      const hud = document.getElementById("hud");
      const startBtn = document.getElementById("startBtn");
      const popup = document.getElementById("popup");
      const tickerHeading = document.getElementById("tickerHeading");
      const tickerSubtitle = document.getElementById("tickerSubtitle");
      const loader = document.getElementById("loader");
      const scanner = document.getElementById("scanner");

      // speech permission flag — enabled by explicit user gesture (Start button)
      let allowSpeech = true;

      // Fun expression messages
      const expressionMessages = {
        happy: ["Radiant Comrade!", "Joy Spreader!", "Sunshine Champion!"],
        sad: ["Captain Serious", "Melancholy Poet", "Blue Mood Master"],
        angry: ["Thunder Face!", "Mighty Grumpy!", "Epic Rage Master!"],
        surprised: [
          "Shock Commander!",
          "Wide-Eyed Wonder!",
          "Surprise Expert!",
        ],
        neutral: ["Zen Master", "Poker Face Pro", "Calm Keeper"],
        fearful: ["Brave Explorer", "Adventure Seeker", "Thrill Master"],
        disgusted: ["Critic Supreme", "Taste Guardian", "Opinion Master"],
      };

      // Short witty subtitles to show under the main popup message
      const expressionSubtitles = {
        happy: [
          "Warning: excessive joy detected.",
          "Smile quota exceeded — congratulations!",
        ],
        sad: [
          "Expert-level brooding in progress.",
          "Steam: handle with kindness.",
        ],
        angry: ["Calm breathing recommended.", "Hot vibes cooling down soon."],
        surprised: ["Blink to confirm reality.", "Alert: curiosity peaked!"],
        neutral: ["Zen mode activated.", "Stoic and stylish."],
        fearful: ["Adrenaline: optional.", "Courage boots are on backorder."],
        disgusted: ["Tastebuds offended.", "Opinionated and proud."],
        default: [
          "Mood detected — processing witty comment.",
          "Nice face, nice vibes.",
        ],
      };

      function getRandomSubtitle(expression) {
        const arr =
          expressionSubtitles[expression.toLowerCase()] ||
          expressionSubtitles.default;
        return arr[Math.floor(Math.random() * arr.length)];
      }

      function formatExpressionLabel(expression) {
        if (!expression) return "Expression detected";
        return expression
          .toString()
          .split(/[\s_-]+/)
          .map(
            (part) => part.charAt(0).toUpperCase() + part.slice(1).toLowerCase()
          )
          .join(" ");
      }

      function setTickerText({ heading = "", subtitle = "" }) {
        if (tickerHeading) tickerHeading.textContent = heading;
        if (tickerSubtitle) tickerSubtitle.textContent = subtitle;
      }

      function showPopup(text, conf, isWelcome = false) {
        if (isWelcome) {
          setTickerText({
            heading: text || "Scanning face",
            subtitle: "Hold steady while we analyze",
          });
        } else {
          const caption = formatExpressionLabel(text);
          const subtitle = getRandomSubtitle(text);
          setTickerText({
            heading: caption,
            subtitle,
          });
          // speak the detected expression when allowed by a prior user gesture
          speak(caption);
        }
        popup.classList.add("show");
      }

      function speak(text) {
        try {
          if (!allowSpeech) return;
          const u = new SpeechSynthesisUtterance(text);
          u.lang = navigator.language || "en-US";
          speechSynthesis.cancel();
          speechSynthesis.speak(u);
        } catch (e) {
          console.warn("speech failed", e);
        }
      }

      // Expression smoothing / change detection
      const SMOOTH_N = 4; // moving average window (frames)
      let history = []; // [{name, score}]
      let lastShown = { name: "", score: 0 };
      const CHANGE_THRESH = 0.1; // minimum change in score to consider "new"
      const SCORE_MIN_TO_ANNOUNCE = 0.45; // only announce if top score >= 0.45
      const EXPRESSION_READY_SCORE = 0.35; // minimum confidence to hide scanner
      const MIN_MS_BETWEEN_POPUPS = 3000; // 3 seconds between expressions
      const SCAN_AUDIO_VOLUME = 0.35;
      const SCAN_AUDIO_SRC = "scan.wav";
      let lastPopupAt = 0;
      // track whether a face is currently visible (to show prompt once per appearance)
      let faceSeen = false;
      let expressionsUnlocked = false;
      let scannerVisible = false;
      // track when expressions should start being announced (after scanning finishes)
      let startExpressionsTime = 0;
      const SCAN_MIN_DURATION = 3000; // scanning overlay minimum duration
      const SCAN_MAX_DURATION = 5000; // scanning overlay maximum duration
      let scanSound = null;
      let scanSoundPlaying = false;

      function scheduleScanHold(now) {
        const duration =
          SCAN_MIN_DURATION +
          Math.random() * (SCAN_MAX_DURATION - SCAN_MIN_DURATION);
        startExpressionsTime = now + duration;
      }

      function ensureScanSound() {
        if (scanSound || typeof Howl === "undefined") return scanSound;
        scanSound = new Howl({
          src: [SCAN_AUDIO_SRC],
          loop: true,
          volume: SCAN_AUDIO_VOLUME,
          preload: true,
        });
        return scanSound;
      }

      function startScanAudio() {
        const sound = ensureScanSound();
        if (!sound) return;
        if (scanSoundPlaying) return;
        sound.stop();
        sound.play();
        scanSoundPlaying = true;
      }

      function stopScanAudio() {
        if (!scanSound || !scanSoundPlaying) return;
        scanSound.stop();
        scanSoundPlaying = false;
      }

      function bestExpression(expressions) {
        let best = { name: "unknown", score: 0 };
        for (const [name, score] of Object.entries(expressions))
          if (score > best.score) best = { name, score };
        return best;
      }

      function smoothBest(newBest) {
        history.push(newBest);
        if (history.length > SMOOTH_N) history.shift();
        // average scores per name seen in history
        const agg = {};
        history.forEach(({ name, score }) => {
          agg[name] = (agg[name] || 0) + score;
        });
        const smoothed = Object.entries(agg).map(([name, sum]) => ({
          name,
          score: sum / history.length,
        }));
        smoothed.sort((a, b) => b.score - a.score);
        return smoothed[0] || newBest;
      }

      function maybeAnnounce(best, canAnnounce) {
        if (!canAnnounce) return;
        const now = Date.now();
        const changedName = best.name !== lastShown.name;
        const changedScore =
          Math.abs(best.score - (lastShown.score || 0)) >= CHANGE_THRESH;
        const confident = best.score >= SCORE_MIN_TO_ANNOUNCE;
        const cooledDown = now - lastPopupAt >= MIN_MS_BETWEEN_POPUPS;

        if (confident && cooledDown && (changedName || changedScore)) {
          showPopup(best.name, best.score);
          lastShown = best;
          lastPopupAt = now;
        }
      }

      function drawBox(box) {
        ctx.strokeStyle = "rgba(255,255,255,.9)";
        ctx.lineWidth = 2;
        ctx.setLineDash([]);
        ctx.strokeRect(box.x, box.y, box.width, box.height);
      }

      function drawLabelOverBox(box, text) {
        const pad = 6;
        ctx.font = "14px system-ui, sans-serif";
        const tw = ctx.measureText(text).width,
          th = 18;
        const tx = box.x + Math.max(0, (box.width - tw) / 2);
        const ty = Math.max(0, box.y - th - 8);
        ctx.fillStyle = "rgba(0,0,0,0.6)";
        ctx.fillRect(tx - pad, ty - th + 4, tw + pad * 2, th);
        ctx.fillStyle = "white";
        ctx.fillText(text, tx, ty);
      }

      function ensureCanvasSizeMatchesVideo() {
        if (
          overlay.width !== video.videoWidth ||
          overlay.height !== video.videoHeight
        ) {
          overlay.width = video.videoWidth;
          overlay.height = video.videoHeight;
        }
      }

      async function loadModels() {
        // Handle both local and GitHub Pages paths
        const repoName = "AI-mirror";
        const MODEL_URL =
          location.hostname === "localhost" || location.hostname === "127.0.0.1"
            ? "./models"
            : `/${repoName}/models`;

        hud.textContent = "loading models…";
        showLoader();
        try {
          await Promise.all([
            faceapi.nets.tinyFaceDetector.loadFromUri(MODEL_URL),
            faceapi.nets.faceExpressionNet.loadFromUri(MODEL_URL),
          ]);
          hud.textContent = "models ready";
          hideLoader();
        } catch (error) {
          console.error("Error loading models:", error);
          hud.textContent = `Error loading models from ${MODEL_URL}. Check console for details.`;
          hideLoader();
          throw error;
        }
      }

      async function setupCamera() {
        hud.textContent = "requesting camera…";
        showLoader();
        const stream = await navigator.mediaDevices.getUserMedia({
          video: {
            facingMode: "user",
            width: { ideal: 720 },
            height: { ideal: 1280 },
            aspectRatio: { ideal: 0.5625 }, // 9:16 portrait ratio
          },
          audio: false,
        });
        video.srcObject = stream;
        await new Promise((r) => (video.onloadedmetadata = r));
        overlay.width = video.videoWidth;
        overlay.height = video.videoHeight;
        hud.textContent = "camera ready";
        hideLoader();
      }

      function showLoader() {
        loader.classList.add("show");
      }
      function hideLoader() {
        loader.classList.remove("show");
      }

      function showScanner() {
        if (!scanner || scannerVisible) return;
        scanner.classList.add("show");
        scanner.setAttribute("aria-hidden", "false");
        scannerVisible = true;
        startScanAudio();
      }

      function hideScanner() {
        if (!scanner || !scannerVisible) return;
        scanner.classList.remove("show");
        scanner.setAttribute("aria-hidden", "true");
        scannerVisible = false;
        stopScanAudio();
      }

      async function startApp() {
        try {
          startBtn.disabled = true;
          await loadModels();
          await setupCamera();

          const opts = new faceapi.TinyFaceDetectorOptions({
            inputSize: 320,
            scoreThreshold: 0.5,
          });
          hud.textContent = "detecting…";

          async function tick() {
            ensureCanvasSizeMatchesVideo();
            const result = await faceapi
              .detectSingleFace(video, opts)
              .withFaceExpressions();

            ctx.clearRect(0, 0, overlay.width, overlay.height);

            if (result) {
              const now = Date.now();
              const firstFrameWithFace = !faceSeen;
              if (firstFrameWithFace) {
                faceSeen = true;
                expressionsUnlocked = false;
                scheduleScanHold(now);
                showScanner();
                showPopup("Scanning face", 1, true);
              }

              const { box } = result.detection;
              drawBox(box);

              const expr = result.expressions || {};
              const keys = Object.keys(expr);

              if (!keys.length) {
                hud.textContent =
                  "face found — expressions missing (check ./models)";
                showScanner();
                requestAnimationFrame(tick);
                return;
              }

              const rawBest = bestExpression(expr);
              const best = smoothBest(rawBest);
              const pct = (best.score * 100).toFixed(0);
              const expressionReady = best.score >= EXPRESSION_READY_SCORE;
              const timerSatisfied =
                !startExpressionsTime || now >= startExpressionsTime;

              if (!expressionsUnlocked && expressionReady && timerSatisfied) {
                expressionsUnlocked = true;
              }

              const scanningActive = !expressionsUnlocked;
              if (scanningActive) {
                showScanner();
                hud.textContent = "scanning face...";
              } else {
                hideScanner();
                drawLabelOverBox(box, `${best.name} ${pct}%`);
                hud.textContent = `expression: ${best.name} (${pct}%)`;
              }

              // Popup if changed / confident
              maybeAnnounce(best, !scanningActive);
            } else {
              // reset face detection state when face disappears
              faceSeen = false;
              startExpressionsTime = 0;
              expressionsUnlocked = false;
              hideScanner();
              hud.textContent = "no face detected";
            }

            requestAnimationFrame(tick);
          }

          tick();
        } catch (err) {
          console.error(err);
          hud.textContent = "error: " + err.message;
          startBtn.disabled = false;
        }
      }

      // Mobile needs a user gesture
      startBtn.addEventListener("click", (ev) => {
        allowSpeech = true;
        startApp();
      });
      // Try auto-start on desktop
      window.addEventListener("load", () => {
        startApp().catch(() => {});
      });
    </script>
  </body>
</html>
